/*
 * Copyright (c) 2007,西安邮电学院Linux兴趣小组
 * All rights reserved.
 *
 * 文件名称：parse_cmd.c
 * 摘    要：从一行数据中解析出命令和参数 并调用相应的命令处理模块 
 * 对读取的字符串做了初步分析 提高了容错能力 对参数的接收做了限制，一次只接收一个参数。
 * 重写了接收参数模块,去掉了无用参数buf_size,_line_cmd()的返回值改成了结构体指针。
 * 当前版本：4.0
 * 作    者：贾孟树
 * 完成日期：2007年6月13日
 * 取代版本：3.0
 * 完成日期：2007年6月8日
 * 修改者：王聪
 * 修改日期：2007年6月15日
 */


#include "xylftp.h"
#include "do_cmd.h"

#define MAX_CMD 5
#define MAX_ARG 4096

extern struct user_env user_env;
extern struct run_env run_env;
struct parse_cmd{
	char	cmd[MAX_CMD];
	char	arg[MAX_ARG];
} ;


const char *commands[] = {"USER","PASS","CWD","CDUP","RETR","STOR","RNFR","RNTO","ABOR","DELE",
		"RMD","MKD","PWD","SYST","QUIT","PORT","NOOP","PASV","TYPE","MODE",
		"STAT","STRU","LIST"};			/*服务器支持的所有命令*/

static void _line_cmd(char *line_buf, struct parse_cmd *user_cmd)
{
	int	i = 0;
	int	j = 0;
	int	k = 0;

	while ((line_buf[i] < 'A') ||
			((line_buf[i] > 'Z') && (line_buf[i] < 'a'))
			|| (line_buf[i] > 'z')) {
		i++;							
	} 		/*<--略过不是字母的字符*/		 		
	while (line_buf[i] != ' '
			&& line_buf[i] != '\r'
			&& line_buf[i] != '\n') {
		if (k < MAX_CMD-1) {
			user_cmd->cmd[k++] = line_buf[i];
			i++;
		}
		else {
			break;
		}
	}		/*<--接收以字母开头的字符串（命令）*/
	while (line_buf[i] == ' ') {		
		i++;	
	} 		/*<--清除命令与参数之间的空格*/
	while (line_buf[i] != '\0'
			&& line_buf[i] != '\r'
			&& line_buf[i] != '\n'
			&& line_buf[i] != ' ') {
		user_cmd->arg[j++] = line_buf[i];
		i++;
	}		/*<--只提取第一个参数*/
	
	for (;k >= 0;k--) {		/*检查命令中字母的大小写，若是小写字母，则转化为大写字母*/
		if (user_cmd->cmd[k] >= 'a'
				&& user_cmd->cmd[k] <= 'z') {
			user_cmd->cmd[k] = user_cmd->cmd[k] - 32;
		} else {
			continue;
		}
	}
#ifdef DEBUG					 
	printf("\n");
	printf("CMD:");
	printf("%s",user_cmd->cmd);
	printf("\n");
	printf("ARG:");
	printf("%s",user_cmd->arg);
	printf("\n");
#endif	
}

static int _cmd_num(struct parse_cmd *p_cmd)
{
	int i;
	for (i = 0; i < (int)(sizeof(commands)/sizeof(commands[0])); i++) {
		if (strcmp(p_cmd->cmd, commands[i]) == 0) {
			return i+1;
		}		
	}
	return 0;
}


int parse_cmd(char *p_buf)
{	
	char	*user_name = "";
	char	*rnfr_arg = "";
	int	banner_len = (int)strlen(run_env.ftpd_banner) + 8;
	char	banner_mess[banner_len];
	
	struct parse_cmd user_cmd = {"", ""} ;
	_line_cmd(p_buf, &user_cmd);

	switch (_cmd_num(&user_cmd)) {
	case 1:
#ifdef DEBUG
			printf("****call user()\n");
#endif
			do_user(user_cmd.arg);
			break;
	case 2:
#ifdef DEBUG
			printf("call pass()\n");
			printf("username=%s\n", user_env.user_name);
#endif

			if (strlen(user_env.user_name) != 0) { 
				if (do_pass(user_cmd.arg) == 0) {
					write(user_env.connect_fd,strcat(strcat(strcat(banner_mess,"230 "), run_env.ftpd_banner),"\r\n"),banner_len);
				}
				user_name = "";	
			} else {
				char	*mess = "220 No username input.\r\n";
				write(user_env.connect_fd, mess, strlen(mess));
			}

			break;
	case 3:
#ifdef DEBUG
			printf("call cwd()\n");
#endif
			//do_cwd(user_cmd.arg);
			break;
	case 4:
#ifdef DEBUG
			printf("call cdup()\n");
#endif
			//do_cdup();
			break;
	case 5:
#ifdef DEBUG
			printf("call retr()\n");
#endif
			//do_retr(user_cmd.arg);
			break;
	case 6:
#ifdef DEBUG
			printf("call stor()\n");
#endif
			//do_stor(user_cmd.arg);
			break;
	case 7:
#ifdef DEBUG
			printf("call rnfr()\n");
#endif
			//do_rnfr();
			rnfr_arg = user_cmd.arg;
			break;
	case 8:
#ifdef DEBUG
			printf("call rnto()\n");
#endif
			if (strcmp(rnfr_arg, "")!=0 && strcmp(user_cmd.arg, "")!=0) {
				//do_rnto(rnfr_arg,user_cmd.arg);
				rnfr_arg = "";
			} else {
				char	*mess = "450 No username input.\r\n";
				printf("\n");
				while ((write(user_env.connect_fd,mess,strlen(mess))) == -1) {
					perror("wirte error");
				} 
			}
			break;
	case 9:
#ifdef DEBUG
			printf("call abor()\n");
			fflush(stdout);
#endif
			//do_abor();
			break;
	case 10:
#ifdef DEBUG
			printf("call dele()\n");
#endif
			//do_dele(user_cmd.arg);
			break;
	case 11:
#ifdef DEBUG
			printf("call rmd()\n");
#endif
			//do_rmd(user_cmd.arg);
			break;
	case 12:
#ifdef DEBUG
			printf("call mkd()\n");
#endif
			//do_mkd(user_cmd.arg);
			break;
	case 13:
#ifdef DEBUG
			printf("call pwd()\n");
#endif
			//do_pwd();
			break;
	case 14:
#ifdef DEBUG
			printf("call syst()\n");
#endif
			//do_syst();
			break;
	case 15:
#ifdef DEBUG
			printf("call quit()\n");
#endif
			//do_quit();
			break;	
	case 16:
#ifdef DEBUG
			printf("call port()\n");
#endif
			//do_port(user_cmd.arg);
			break;	
	case 17:
#ifdef DEBUG
			printf("call noop()\n");
#endif
			//do_noop();	
			break;
	case 18:
#ifdef DEBUG
			printf("call pasv()\n");
			printf("\n");
#endif
			do_pasv();
			break;
	case 19:
#ifdef DEBUG
			printf("call type()\n");
#endif
			//do_type(user_cmd.arg);
			break;
	case 20:
#ifdef DEBUG
			printf("call mode()\n");
#endif
			do_mode(user_cmd.arg);
			break;
	case 21:
#ifdef DEBUG
			printf("call stat()\n");
#endif
			//do_stat(user_cmd.arg);
			break;
	case 22:
#ifdef DEBUG
			printf("call stru()\n");
#endif
			//do_stru();
			break;
	case 23:
#ifdef DEBUG
			printf("call list()\n");
#endif
			//do_list(user_cmd.arg);
			break;
	case 0:
#ifdef DEBUG
			printf("call failed()\n");
#endif
			//failed();
			break;
	}		
	return 1;
}
